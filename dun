#!/bin/bash

# Freeform task tracking for plain text notes


_error() {
  echo "Error: $1" 1>&2
  exit 1
}


_dun_list_tags() {
  # -h = --no-filename
  # -s = --no-messages
  # -o = --only-matching
  cd "$NOTES_DIR" && grep -s -h -o "#[^# \"',.]\+" * | sort | uniq
}


_dun_update_vim_dictionary() {
  # Write tags and statuses to vim dictionary file

  for s in ${STATUSES_TODO[@]} ${STATUSES_BLOCK[@]} ${STATUSES_DONE[@]}; do
    echo $s
  done

  _dun_list_tags

}


_dun_update_vim_config() {
  # Write vim conig file with respect to configured status and vim highlight group settings

  echo "\" WARNING! This file is autogenerated by dun. Changes made here may be lost

\" Dictionary completion of statuses and tags
if filereadable(\".dun_vim_dictionary\")
  set complete+=k.dun_vim_dictionary
endif

\" Highlight groups for dun statuses and tags
highlight dunTODO $VIM_STATUSES_TODO_STYLE
highlight dunBLOCK $VIM_STATUSES_BLOCK_STYLE
highlight dunDONE $VIM_STATUSES_DONE_STYLE
highlight dunTAG $VIM_TAG_STYLE
"

  # Matchadd applies highlight groups to text
  for s in ${STATUSES_TODO[@]}; do
    echo "call matchadd('dunTODO', '\\<$s\\>', 50)"
  done
  for s in ${STATUSES_BLOCK[@]}; do
    echo "call matchadd('dunBLOCK', '\\<$s\\>', 50)"
  done
  for s in ${STATUSES_DONE[@]}; do
    echo "call matchadd('dunDONE', '\\<$s\\>', 50)"
  done

  # Matchadd tags
  echo "call matchadd('dunTag', '\\v#[^ #]+', 50)"
}


_dun_vim_support() {
  # Setup autocomplete and syntax highlighting for vim
  if [ "$VIM_SUPPORT" = "enabled" ]; then
    _dun_update_vim_config > "$NOTES_DIR/.dun_vimrc"
    _dun_update_vim_dictionary > "$NOTES_DIR/.dun_vim_dictionary"
  fi
}


_dun_open_editor() {
  # Open file, optionally on a given line
  # If you want some other editor(!?), here is your chance;)
  filename=$1
  line_number=$2

  if [ $# -eq 2 ]; then
    line_option="+$line_number"
  fi

  # Freshen vim config before and after edit. Afterwards incase open notes directly from vim
  _dun_vim_support
  vim $line_option "$filename"
  _dun_vim_support
}


_dun_regexp_statuses() {
  # Helper function to make regexp for matching statuses
  statuses=("$@")
  regexp=''
  for s in "${statuses[@]}"; do
    regexp="$regexp|$s"
  done
  echo "(${regexp:1})"
}


_dun_colorize() {
  # Color statuses, tags and file names
  # To make this pretty there is a lot of font coloring going on
  # https://misc.flogisoft.com/bash/tip_colors_and_formatting
  # Oneliner to list colors:
  # for x in {0..8}; do for i in {30..37}; do for a in {40..47}; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo ""

  sed -r "\
# Colorizes output:
# Todo statuses
s/$TODOS/${ESC}${STATUSES_TODO_STYLE}&${NO_STYLE}/g \
# Block statuses
; s/$BLOCKS/${ESC}${STATUSES_BLOCK_STYLE}&${NO_STYLE}/g \
# Done statuses
; s/$DONES/${ESC}${STATUSES_DONE_STYLE}&${NO_STYLE}/g \
# Tags
; s/#[^# \"']+/${ESC}${TAGS_STYLE}&${NO_STYLE}/g \
" /dev/stdin
}


_dun_edit_lines() {
  # Accepts a title and command that will list tasks (lines in note files) and allows user to select a line and open it in editor repeatedly
  # $1 argument is the command that when evaluated must produce output in format <filename>:<line number>:<line text>

  title="$1"
  cmd="$2"

  # The loop evaluates the command argument and allows user to select a line to edit
  while true; do
    # Read result of command (must be in correct format, see above)
    readarray lines < <(eval $cmd)

    # No tasks found:(
    if [ ${#lines[@]} -eq 0 ]; then
      exit 1
    fi

    title_string="$(printf "%s" "$title" | _dun_colorize)"

    selection="$(for ((i=0;i<${#lines[@]};i++)); do
      IFS=':' read -r -a line <<< "${lines[$i]}"
      filename="${line[0]}"
      line_number="${line[1]}"
      line_text="$(echo "${line[2]}" | sed 's/^[ \t]*// ; s/^-// ; s/^[ \t]*//')"

      printf "%s:%s (%s)\n" "$i" "$line_text" "$filename"

    done | _dun_colorize | fzf --exact --ansi --delimiter=':' --with-nth 2.. --cycle "--header=$title_string. Shift+[up|down] to scroll preview" '--preview=echo {} | sed "s/^[0-9]*://" | dun colorize' --bind shift-up:preview-page-up,shift-down:preview-page-down --preview-window up,3,wrap)"

    # Strip off task content, leaving only array index to $lines
    selection=${selection//:*}

    # Open selected file at given location in editor
    if [ "$selection" -le ${#lines[@]} ] 2>/dev/null ; then
      IFS=':' read -ra selected_file <<< ${lines[$selection]}

      _dun_open_editor "${selected_file[0]}" "${selected_file[1]}"
    else
      exit 0
    fi
  done
}


_dun_usage() {
  printf "\e[1mUsage\e[0m dun [archive-notes|new-note|notes|recent-notes|tasks|help|task-complete-options|colorize] <note file>\n"
}

_dun_print_help() {
  echo -e '
Task tracking from freeform notes. Tasks are single lines of text containing a status and optionally one or more tags. Notes are plain text files.

    \e[1marchive-notes\e[0m
        Move notes that have no tasks, or only done tasks, to archive directory

    \e[1mnew-note\e[0m [NAME STRING]
        Create new note text file in NOTES_DIR. If Name is specified the file name will be  yyyy-mm-dd-[name]-[increment], else just yyyy-mm-dd-[increment].

        \e[1mExample:\e[0m
            $ dun new retrospective
                File name will be yyyy-mm-dd-retrospective-0 (if the file already exists the -0 will increment until the file name is unique)

    \e[1mnotes\e[0m
        List and filter note files

    \e[1mrecent-notes\e[0m [NUMBER]
        List the first Number of recently modified note files. Number defaults to 9.

    \e[1mtasks\e[0m [[+|-]<FILTER STRING>..]
        List and filter tasks, if dun is run with no arguments it defaults to showing tasks. Default list tasks with first status defined in TODO BLOCK (see dun.conf). Filter strings are prefixed by either + or -. Prefix + will match if the string is present, whilst prefix - means the string must be absent.

        \e[1mExample:\e[0m
            $ dun list +#ProjectA -DONE
                List tasks that are tagged #ProjectA and are not DONE

    \e[1mtags\e[0m
        List tags found in notes

    \e[1mcolorize\e[0m
        Colorize stdin

    \e[1mtask-complete-options\e[0m
        Print statuses and tags found in notes, for use with bash complete

    \e[1mhelp\e[0m
        This text.
' | fmt

  _dun_usage
}


_dun_check_dependencies() {
  for dep in "$@"; do
    command -v "$dep" >/dev/null 2>&1 || { echo >&2 "Command $dep not found"; exit 1; }
  done
}


# For all git repositories in vault, run batch commands
_git_sync() {

  local action="$1"
  local git_dir="$NOTES_DIR/.git"

  [ -d "$git_dir" ] || return

  [ "$GIT_SYNC" != "enabled" ] && return

  if ! command -v git &> /dev/null; then
      _error "git command not found"
  fi

  cd "$NOTES_DIR" || _error "Unable to cd to $NOTES_DIR"

  if [[ $(git branch -r) ]]; then
    has_remote="yes"
  else
    has_remote="no"
  fi

  case $action in
    pull)
      if [ "$has_remote" = "yes" ]; then
        #echo "Checking for updates to $git_dir.."
        git pull --quiet || _error "Unable to pull from remote repo"
      fi
    ;;
    commitpush)
      # Check if changes, if so commit and push
      if [ -n "$(git status --porcelain)" ]; then
        #echo "Modifications found in $git_dir.."
        git add -A || _error "Git add failed"
        git commit -m 'Overtake sync' --quiet || _error "Git commit failed"

        if [ "$has_remote" = "yes" ]; then
          #echo "Uploading changes to $git_dir.."
          git push --quiet || _error "Unable to push to remote git"
        fi
      fi
    ;;
    *) _error "No valid action supplied for _git_sync()" ;;
  esac
}


_dun_check_dependencies vim fzf grep awk

# Settings defaults
NOTES_DIR=~/dun
ARCHIVE_DIR=~/dun/archive
STATUSES_TODO=('TODO')
STATUSES_BLOCK=('WAIT')
STATUSES_DONE=('WONT' 'DONE')
STATUSES_TODO_STYLE='[1;37;44m'
STATUSES_BLOCK_STYLE='[1;37;43m'
STATUSES_DONE_STYLE='[1;37;42m'
HIGHLIGHT_STYLE='[0;35m'
TAGS_STYLE='[1;37;46m'
VIM_STATUSES_TODO_STYLE='ctermbg=darkblue ctermfg=white cterm=bold'
VIM_STATUSES_BLOCK_STYLE='ctermbg=darkyellow ctermfg=white cterm=bold'
VIM_STATUSES_DONE_STYLE='ctermbg=darkgreen ctermfg=white cterm=bold'
VIM_TAG_STYLE='ctermbg=darkcyan ctermfg=white cterm=bold'
VIM_SUPPORT='disabled'
GIT_SYNC='disabled'

# Load config file
conf_file=~/.config/dun.conf
if [ -f $conf_file ]; then
  source $conf_file
fi

# Setup globals
ESC=$(printf '\033')
NO_STYLE=$(printf '\033[0m')

TODOS="$(_dun_regexp_statuses "${STATUSES_TODO[@]}")"
BLOCKS="$(_dun_regexp_statuses "${STATUSES_BLOCK[@]}")"
DONES="$(_dun_regexp_statuses "${STATUSES_DONE[@]}")"

# Create notes dir if it doesn't exist
if [ -d "$NOTES_DIR" ]; then
  cd "$NOTES_DIR"
else
  echo -e "$NOTES_DIR does not exist (change NOTES_DIR in dun.conf for another location), type \e${HIGHLIGHT_STYLE}[c]\e[0m to create or \e${HIGHLIGHT_STYLE}anything else\e[0m to exit"
  read selection
  if [ "$selection" = "c" ]; then
    mkdir -p "$NOTES_DIR"
  else
    exit 0
  fi 
fi

if [ $# -eq 0 ]; then
  action="tasks"
else
  action=$1
fi

case $action in
  help|task-complete-options|colorize) : ;; # Don't sync git
  *) _git_sync pull ;;
esac

case $action in
  help)
     _dun_print_help
   ;;

  archive-notes)
    # Move notes that have no tasks or only tasks that are done to archive directory

    # Create archive dir if it doesn't exist
    if [ ! -d "$ARCHIVE_DIR" ]; then
      echo -e "$ARCHIVE_DIR does not exist (change ARCHIVE_DIR in dun.conf for another location), type \e${HIGHLIGHT_STYLE}[c]\e[0m to create or \e${HIGHLIGHT_STYLE}anything else\e[0m to exit"
      read selection
      if [ "$selection" = "c" ]; then
        mkdir -p "$ARCHIVE_DIR"
      else
        exit 0
      fi 
    fi

    # Tasks statuses that still have work pending
    live_statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}")
    regexp=''

    for s in ${live_statuses[@]}; do
      regexp="$regexp\|$s"
    done
    regexp="${regexp:2}"

    # Grep to find notes with no open tasks
    # sed removes filepath
    # fzf to view and select notes to archive
    # grep
    #   -l = --files-without-match
    #   -s = --no-messages
    archive_candidates="$(grep "$regexp" -l -s $NOTES_DIR/* | sed "s#.*/##g")"

    [ "$archive_candidates" = "" ] && exit 0

    echo "$archive_candidates" \
    | fzf --exact --multi --cycle "--header=Archive notes. Tab to select multiple, shift+[up|down] to scroll preview" --preview-window right,wrap '--preview=dun colorize < {}' --bind shift-up:preview-page-up,shift-down:preview-page-down \
    | while read f; do
      mv "$NOTES_DIR/$f" "$ARCHIVE_DIR/."
      echo -e "Archived ${f##*/}"
    done

  ;;

  notes)
    # Search notes dir using fzf and open selection in editor

    while true; do
      f="$(find "$NOTES_DIR" -not -path '*/.*' -type f \
      | sed "s#$NOTES_DIR/##g" \
      | fzf --exact --cycle "--header=Notes. Shift+[up|down] to scroll preview" --preview-window right,wrap '--preview=dun colorize < {}' --bind shift-up:preview-page-up,shift-down:preview-page-down)"

      # Exit cleanly if no selection was made in fzf
      [ $? -eq 130 ] && exit 0

      [ -e "$f" ] && _dun_open_editor "$f"
    done
  ;;

  new-note)
    # Create new file in NOTES_DIR
    num=0

    if [ $# -eq 2 ]; then
      note_name=-$2
    else
      note_name=''
    fi

    new_file="$NOTES_DIR/$(date +%Y%m%d)$note_name"

    while [ -e "${new_file}-$num" ]; do
      num=$((num +1))
    done

    new_file="${new_file}-$num"

    _dun_open_editor "$new_file"

  ;;

  recent-notes)
    #Select to open one of X recently modified files from NOTES_DIR or open the last modified note

    if [ "$2" != "" ]; then
      max_count=$2
    else
      max_count=99
    fi

    # find just files in NOTES_DIR and get their epoch and date stamp, sort (because epoch is first)
    # returning $max_count most recent. Use awk and sed to mangle lines so they confirm to expected input
    _dun_edit_lines "Recently modified" "LC_ALL=en_US.UTF-8 find '$NOTES_DIR' -maxdepth 1 -not -path '*/.*' -type f -exec date -r {} +%s:%Y-%m-%d\ %a\ week\ %V:{} \; | sort --reverse | head -$max_count | awk 'BEGIN { FS = \":\" } ; { print \$3 \":0:\" \$2 }' | sed 's#^$NOTES_DIR/##'"

  ;;

  tasks)
    # List tasks filtered by +<word> -<word>

    awk_filter=''
    filters=''

    if [ $# -lt 2 ]; then
      # If no filters provided, default to first todo status
      for s in ${STATUSES_TODO[0]}; do
        awk_filter="$awk_filter && /$s/"
        filters="$filters +${s}"
      done
    else
      shift

      ## Create awk command to filter lines and set arguments
      while (( $# )); do
        filters="$filters $1"
        case ${1:0:1} in
          +)
            awk_filter="$awk_filter && /${1:1}/"
            ;;
          -)
            awk_filter="$awk_filter && !/${1:1}/"
            ;;
          *)
            echo "Filters must start with either + or -"
            exit 1
            ;;
        esac
        shift
      done
    fi

    awk_filter="${awk_filter:4}" # Remove first '&& '
    # Create list of the note files, use instead of * to ensure only files and that quoteing is correct
    # The -not -path ignores dot/hidden files
    note_files="$(find . -maxdepth 1 -not -path '*/.*' -type f | sed "s/^\.\//'/ ; s/$/'/" | tr '\n' ' ')"

    _dun_edit_lines "Tasks, filters$filters" "awk '$awk_filter {print FILENAME \":\" FNR \":\" \$0}' $note_files | sort"
  ;;

  task-complete-options)
    # Print bash complete options

    # tags and statuses start either with a - or +|
    statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}" "${STATUSES_DONE[@]}")
    readarray tags < <(_dun_list_tags)
    filters=("${statuses[@]}" "${tags[@]}")
    for ((i=0;i<${#filters[@]};i++)); do
      options="$options +${filters[$i]} -${filters[$i]}"
    done

    echo "$options" | tr -d '\n'
  ;;

  tags)
    _dun_list_tags | column -c $(tput cols) | column -t
  ;;

  colorize)
    _dun_colorize
  ;;

  *)
    if [ -f "$1" ]; then
      _dun_open_editor "$1"
    else
      echo "Unknown argument: $1"
      _dun_usage
      exit 1
    fi
  ;;

esac

case $action in
  help|task-complete-options|colorize) : ;; # Don't sync git
  *) _git_sync commitpush ;;
esac

