#!/bin/bash

# Freeform task tracking for plain text notes

_dun_open_editor() {
  # Open file, optionally on a given line
  # If you want some other editor(!?), here is your chance;)
  filename=$1
  line_number=$2

  if [ $# -eq 2 ]; then
    line_option=" +$line_number"
  fi

  vim -c 'set syntax=dun'$line_option "$filename"
}

_dun_list_tags() {
  cd "$NOTES_DIR" && grep --directories=skip --no-filename --only-matching "#[^# \"']\+" * | sort | uniq
}


_dun_regexp_statuses() {
  # Helper function to make regexp for matching statuses
  statuses=("$@")
  regexp=''
  for s in "${statuses[@]}"; do
    regexp="$regexp|$s"
  done
  echo "(${regexp:1})"
}


_dun_edit_lines() {
  # Accepts a title and command that will list tasks (lines in note files) and allows user to select a line and open it in editor repeatedly
  # $1 argument is the command that when evaluated must produce output in format <filename>:<line number>:<line text>

  # To make this pretty there is a lot of font coloring going on
  # https://misc.flogisoft.com/bash/tip_colors_and_formatting
  # Oneliner to list colors:
  # for x in {0..8}; do for i in {30..37}; do for a in {40..47}; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo ""
  terminal_width=$(tput cols)
  tabs 5 # set tabs width
  let line_column=$terminal_width-16
  ESC=$(printf '\033')
  NO_STYLE=$(printf '\033[0m')
  title="$1"
  cmd="$2"

  # The loop evaluates the command argument and allows user to select a line to edit
  while true; do
    readarray lines < <(eval $cmd)

    if [ ${#lines[@]} -eq 0 ]; then
      # No tasks found:(
      exit 1
    fi

    todos="$(_dun_regexp_statuses "${STATUSES_TODO[@]}")"
    blocks="$(_dun_regexp_statuses "${STATUSES_BLOCK[@]}")"
    dones="$(_dun_regexp_statuses "${STATUSES_DONE[@]}")"

    clear

    printf "%s\n" "$title " | sed -r \
" s/(^[^+\-]*)\ /${ESC}[1m\1${NO_STYLE}/\
; s/([+\-])#([^\ ]*)\ / \1${ESC}${TAGS_STYLE} #\2 ${NO_STYLE}/g \
; s/([+\-])$todos\ / \1${ESC}${STATUSES_TODO_STYLE} \2 ${NO_STYLE}/g \
; s/([+\-])$blocks\ / \1${ESC}${STATUSES_BLOCK_STYLE} \2 ${NO_STYLE}/g \
; s/([+\-])$dones\ / \1${ESC}${STATUSES_DONE_STYLE} \2 ${NO_STYLE}/g"

    for ((i=0;i<${#lines[@]};i++)); do
      IFS=':' read -r -a line <<< "${lines[$i]}"
      filename="${line[0]}"
      line_number="${line[1]}"
      line_text="$(echo "${line[2]}" | sed 's/^ *// ; s/^-// ; s/^ *//')"

      printf "\n%s\t%s\n" "$i" "$line_text"
      printf "\tfile://%s" "$filename"

         # perl makes text into column, and sed colorizes output
    done | perl -lpe "s/(.{$line_column,}?)\s/\$1\n\t/g" | sed -r "\
# Remove preceeding spaces and dashes
s/^\ *// ; s/^-// ; s/^\ *// \
# Todo statuses
s/$todos/${ESC}${STATUSES_TODO_STYLE} \1 ${NO_STYLE}/g \
# Block statuses
; s/$blocks/${ESC}${STATUSES_BLOCK_STYLE} & ${NO_STYLE}/g \
# Done statuses
; s/$dones/${ESC}${STATUSES_DONE_STYLE} & ${NO_STYLE}/g \
# Tags
; s/#[^# \"']+/${ESC}${TAGS_STYLE} & ${NO_STYLE}/g \
# Select numbers
; s/^([0-9]*)/${ESC}${HIGHLIGHT_STYLE}&${NO_STYLE}/ \
# file name
; s_file://(.*)_${ESC}${FILENAME_STYLE}\\1${NO_STYLE}_g \
"

    # Ask user to select line
    let y=${#lines[@]}-1
    printf "\nType \e${HIGHLIGHT_STYLE}0-%s${NO_STYLE} to select, anything else exits\n" "$y"
    read selection < /dev/tty

    # Open selected file at given location in editor
    if [ "$selection" -le ${#lines[@]} ] 2>/dev/null ; then
      IFS=':' read -ra selected_file <<< ${lines[$selection]}

      _dun_open_editor "${selected_file[0]}" "${selected_file[1]}"
    else
      exit 0
    fi
  done
}


# Settings defaults
NOTES_DIR=~/dun
ARCHIVE_DIR=~/dun/archive
STATUSES_TODO=("TODO")
STATUSES_BLOCK=("WAIT")
STATUSES_DONE=("WONT" "DONE")
STATUSES_TODO_STYLE="[1;37;44m"
STATUSES_BLOCK_STYLE="[1;37;43m"
STATUSES_DONE_STYLE="[1;37;42m"
HIGHLIGHT_STYLE="[0;35m"
FILENAME_STYLE="[0;32m"
TAGS_STYLE="[1;37;46m"

# Load config file
conf_file=~/.config/dun.conf
if [ -f $conf_file ]; then
  source $conf_file
fi

# Create notes dir if it doesn't exist
if [ -d "$NOTES_DIR" ]; then
  cd "$NOTES_DIR"
else
  echo "$NOTES_DIR does not exist (change NOTES_DIR in dun.conf for another location). Create it? [y|n]"
  read selection
  if [ "$selection" = "y" ]; then
    mkdir -p "$NOTES_DIR"
  else
    exit 0
  fi 
fi

case $1 in
  help)

    echo -e '
Task tracking from freeform notes. Tasks are single lines of text containing a status and optionally one or more tags. Notes are plain text files.

\e[1mdun\e[0m [archive|list|new|open-last|recent|tags|bash-complete-options|help]\e[0m

    \e[1marchive\e[0m
        Move notes that have no tasks, or only done tasks, to archive directory

    \e[1mlist\e[0m [[+|-]<FILTER STRING>..]
        List and filter tasks, if no filter specified all tasks with status in status categories TODO and BLOCK will be listedi (see dun.conf). Filter strings are prefixed by either + or -. Prefix + will match if the string is present, whilst prefix - means the string must be absent.

        \e[1mExample:\e[0m
            $ dun list +#ProjectA -DONE
                List tasks that are tagged #ProjectA and are not DONE

    \e[1mnew\e[0m [NAME STRING]
        Create new note text file in NOTES_DIR. If Name is specified the file name will be  yyyy-mm-dd-[name]-[increment], else just yyyy-mm-dd-[increment].

        \e[1mExample:\e[0m
            $ dun new retrospective
                File name will be yyyy-mm-dd-retrospective-0 (if the file already exists the -0 will increment until the file name is unique)

    \e[1mopen-last\e[0m
        Open most recently modified note

    \e[1mrecent\e[0m [NUMBER]
        List the first Number of recently modified note files. Number defaults to 9.

    \e[1mtags\e[0m
        List tags found in notes

    \e[1mbash-complete-options\e[0m
        Print options for use with bash complete

    \e[1mhelp\e[0m
        This text.
' | fmt
    ;;

  archive)
    # Move notes that have no tasks or only tasks that are done to archive directory

    # Create archive dir if it doesn't exist
    if [ ! -d "$ARCHIVE_DIR" ]; then
      echo "$ARCHIVE_DIR does not exist (change ARCHIVE_DIR in dun.conf for another location). Create it? [y|n]"
      read selection
      if [ "$selection" = "y" ]; then
        mkdir -p "$ARCHIVE_DIR"
      else
        exit 0
      fi 
    fi

    # Tasks statuses that still have work pending
    live_statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}")
    regexp=''

    for s in ${live_statuses[@]}; do
      regexp="$regexp\|$s"
    done
    regexp="${regexp:2}"

    grep "$regexp" --files-without-match --directories=skip $NOTES_DIR/* | while read f; do
      echo "Archiving: $f"
      mv "$f" "$ARCHIVE_DIR/." 
    done
    ;;

  new)
    # Create new file in NOTES_DIR
    num=0

    if [ $# -eq 2 ]; then
      note_name=-$2
    else
      note_name=''
    fi

    new_file="$NOTES_DIR/$(date +%Y%m%d)$note_name"

    while [ -e "${new_file}-$num" ]; do
      num=$((num +1))
    done

    new_file="${new_file}-$num"

    _dun_open_editor "$new_file"

    ;;

  recent)
    #Select to open one of X recently modified files from NOTES_DIR or open the last modified note

    if [ "$2" != "" ]; then
      max_count=$2
    else
      max_count=10
    fi

    # find just files in NOTES_DIR and get their epoch and date stamp, sort (because epoch is first)
    # returning $max_count most recent. Use awk and sed to mangle lines so they confirm to expected input
    _dun_edit_lines "Recently modified" "LC_ALL=en_US.UTF-8 find '$NOTES_DIR' -maxdepth 1 -type f -exec date -r {} +%s:%Y-%m-%d\ %a\ week\ %V:{} \; | sort --reverse | head -$max_count | awk 'BEGIN { FS = \":\" } ; { print \$3 \":0:\" \$2 }' | sed 's#^$NOTES_DIR/##'"

    ;;

  open-last)
    # Open the most recently modified note

    last_modified="$(find . -maxdepth 1 -type f -printf '%T@ %p\n' | sort -k1,1nr | head -1 | sed 's_.*\./__')"
    [ -f "$last_modified" ] && _dun_open_editor "$last_modified" 0

    ;;

  list)
    # List tasks filtered by +<word> -<word>

    awk_filter=''
    filters=''

    if [ $# -eq 1 ]; then
      # _If no filters provided, default to filter by any status in TODO and BLOCK categories
      live_statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}")
      for s in ${live_statuses[@]}; do
        awk_filter="$awk_filter || /$s/"
        filters="$filters +${s}"
      done
    else
      shift

      ## Create awk command to filter lines and set arguments
      while (( $# )); do
        filters="$filters $1"
        case ${1:0:1} in
          +)
            awk_filter="$awk_filter && /${1:1}/"
            ;;
          -)
            awk_filter="$awk_filter && !/${1:1}/"
            ;;
          *)
            echo "Filters must start with either + or -"
            exit 1
            ;;
        esac
        shift
      done
    fi

    awk_filter="${awk_filter:4}" # Remove first '&& '
    # Create list of the note files, use instead of * to ensure only files and that quoteing is correct
    note_files="$(find . -maxdepth 1 -type f | sed "s/^\.\//'/ ; s/$/'/" | tr '\n' ' ')"

    _dun_edit_lines "Task filters$filters" "awk '$awk_filter {print FILENAME \":\" FNR \":\" \$0}' $note_files | sort"
    ;;

  bash-complete-options)
    # Print bash complete options

    options="archive list new open-last recent tags bash-complete-options help"

    # tags and statuses start either with a - or +
    statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}" "${STATUSES_DONE[@]}")
    readarray tags < <(_dun_list_tags)
    filters=("${statuses[@]}" "${tags[@]}")
    for ((i=0;i<${#filters[@]};i++)); do
      options="$options +${filters[$i]} -${filters[$i]}"
    done

    echo "$options" | tr -d '\n'
    ;;

  tags)
    _dun_list_tags | column
    ;;

  *)
    echo -e 'Unknown arguments:( Maybe try \e[1mdun help\e[0m?'
    exit 1
    ;;
esac

