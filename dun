#!/bin/bash

# Freeform task tracking for plain text notes

_dun_list_tags() {
  cd "$NOTES_DIR" && grep --directories=skip --no-filename --only-matching "#[^# \"']\+" * | sort | uniq
}


_dun_update_vim_dictionary() {
  # Write tags and statuses to vim dictionary file

  for s in ${STATUSES_TODO[@]} ${STATUSES_BLOCK[@]} ${STATUSES_DONE[@]}; do
    echo $s
  done

  _dun_list_tags

}


_dun_update_vim_config() {
  # Write vim conig file with respect to configured status and vim highlight group settings

  echo "\" WARNING! This file is autogenerated by dun. Changes made here may be lost

\" Dictionary completion of statuses and tags
if filereadable(\".dun_vim_dictionary\")
  set complete+=k.dun_vim_dictionary
endif

\" Highlight groups for dun statuses and tags
highlight dunTODO $VIM_STATUSES_TODO_STYLE
highlight dunBLOCK $VIM_STATUSES_BLOCK_STYLE
highlight dunDONE $VIM_STATUSES_DONE_STYLE
highlight dunTAG $VIM_TAG_STYLE
"

  # Matchadd applies highlight groups to text
  for s in ${STATUSES_TODO[@]}; do
    echo "call matchadd('dunTODO', '\\<$s\\>', 50)"
  done
  for s in ${STATUSES_BLOCK[@]}; do
    echo "call matchadd('dunBLOCK', '\\<$s\\>', 50)"
  done
  for s in ${STATUSES_DONE[@]}; do
    echo "call matchadd('dunDONE', '\\<$s\\>', 50)"
  done

  # Matchadd tags
  echo "call matchadd('dunTag', '\\v#[^ #]+', 50)"
}


_dun_vim_support() {
  # Setup autocomplete and syntax highlighting for vim
  if [ "$VIM_SUPPORT" = "enabled" ]; then
    _dun_update_vim_config > "$NOTES_DIR/.dun_vimrc"
    _dun_update_vim_dictionary > "$NOTES_DIR/.dun_vim_dictionary"
  fi
}


_dun_open_editor() {
  # Open file, optionally on a given line
  # If you want some other editor(!?), here is your chance;)
  filename=$1
  line_number=$2

  if [ $# -eq 2 ]; then
    line_option="+$line_number"
  fi

  # Freshen vim config before and after edit. Afterwards incase open notes directly from vim
  _dun_vim_support
  vim $line_option "$filename"
  _dun_vim_support
}


_dun_regexp_statuses() {
  # Helper function to make regexp for matching statuses
  statuses=("$@")
  regexp=''
  for s in "${statuses[@]}"; do
    regexp="$regexp|$s"
  done
  echo "(${regexp:1})"
}


_dun_edit_lines() {
  # Accepts a title and command that will list tasks (lines in note files) and allows user to select a line and open it in editor repeatedly
  # $1 argument is the command that when evaluated must produce output in format <filename>:<line number>:<line text>

  # To make this pretty there is a lot of font coloring going on
  # https://misc.flogisoft.com/bash/tip_colors_and_formatting
  # Oneliner to list colors:
  # for x in {0..8}; do for i in {30..37}; do for a in {40..47}; do echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "; done; echo; done; done; echo ""
  ESC=$(printf '\033')
  NO_STYLE=$(printf '\033[0m')
  title="$1"
  cmd="$2"

  # The loop evaluates the command argument and allows user to select a line to edit
  while true; do
    # Read result of command (must be in correct format, see above)
    readarray lines < <(eval $cmd)

    # No tasks found:(
    if [ ${#lines[@]} -eq 0 ]; then
      exit 1
    fi

    todos="$(_dun_regexp_statuses "${STATUSES_TODO[@]}")"
    blocks="$(_dun_regexp_statuses "${STATUSES_BLOCK[@]}")"
    dones="$(_dun_regexp_statuses "${STATUSES_DONE[@]}")"

    title_string=$(printf "%s\n" "$title " | sed -r " \
# Make everything until first + or - bold
s/(^[^+\-]*)\ /${ESC}[1m\1${NO_STYLE} /\
# Color tags
; s/([+\-])#([^\ ]*)/\1${ESC}${TAGS_STYLE}#\2${NO_STYLE}/g \
# Color statuses
; s/([+\-])$todos/\1${ESC}${STATUSES_TODO_STYLE}\2${NO_STYLE}/g \
; s/([+\-])$blocks/\1${ESC}${STATUSES_BLOCK_STYLE}\2${NO_STYLE}/g \
; s/([+\-])$dones/\1${ESC}${STATUSES_DONE_STYLE}\2${NO_STYLE}/g")
# \
#; s/[^\ ]([+\-])/ \1/g")

    selection="$(for ((i=0;i<${#lines[@]};i++)); do
      IFS=':' read -r -a line <<< "${lines[$i]}"
      filename="${line[0]}"
      line_number="${line[1]}"
      line_text="$(echo "${line[2]}" | sed 's/^ *// ; s/^-// ; s/^ *//')"

      printf "%s:%s file://%s\n" "$i" "$line_text" "$filename"

    done | sed -r "\
# Colorizes output:
# Todo statuses
s/$todos/${ESC}${STATUSES_TODO_STYLE}&${NO_STYLE}/g \
# Block statuses
; s/$blocks/${ESC}${STATUSES_BLOCK_STYLE}&${NO_STYLE}/g \
# Done statuses
; s/$dones/${ESC}${STATUSES_DONE_STYLE}&${NO_STYLE}/g \
# Tags
; s/#[^# \"']+/${ESC}${TAGS_STYLE}&${NO_STYLE}/g \
# file name
; s_file://(.*)_${ESC}${FILENAME_STYLE}\\1${NO_STYLE}_g \
" | fzf --ansi --delimiter=':' --with-nth 2.. --cycle "--header=$title_string")"

    # Strip off task content, leaving only array index to $lines
    selection=${selection//:*}

    # Open selected file at given location in editor
    if [ "$selection" -le ${#lines[@]} ] 2>/dev/null ; then
      IFS=':' read -ra selected_file <<< ${lines[$selection]}

      _dun_open_editor "${selected_file[0]}" "${selected_file[1]}"
    else
      exit 0
    fi
  done
}


_dun_print_help() {
  echo -e '
Task tracking from freeform notes. Tasks are single lines of text containing a status and optionally one or more tags. Notes are plain text files.

\e[1mdun\e[0m [archive|find|list|new|open-last|recent|tags|bash-complete-options|help]\e[0m

    \e[1marchive\e[0m
        Move notes that have no tasks, or only done tasks, to archive directory

    \e[1mfind\e[0m
        Search notes directory by file name

    \e[1mlist\e[0m [[+|-]<FILTER STRING>..]
        List and filter tasks, default list tasks with first status defined in TODO BLOCK (see dun.conf). Filter strings are prefixed by either + or -. Prefix + will match if the string is present, whilst prefix - means the string must be absent.

        \e[1mExample:\e[0m
            $ dun list +#ProjectA -DONE
                List tasks that are tagged #ProjectA and are not DONE

    \e[1mnew\e[0m [NAME STRING]
        Create new note text file in NOTES_DIR. If Name is specified the file name will be  yyyy-mm-dd-[name]-[increment], else just yyyy-mm-dd-[increment].

        \e[1mExample:\e[0m
            $ dun new retrospective
                File name will be yyyy-mm-dd-retrospective-0 (if the file already exists the -0 will increment until the file name is unique)

    \e[1mopen-last\e[0m
        Open most recently modified note

    \e[1mrecent\e[0m [NUMBER]
        List the first Number of recently modified note files. Number defaults to 9.

    \e[1mtags\e[0m
        List tags found in notes

    \e[1mbash-complete-options\e[0m
        Print options for use with bash complete

    \e[1mhelp\e[0m
        This text.
' | fmt
}


function _dun_check_dependencies() {
  for dep in "$@"; do
    command -v "$dep" >/dev/null 2>&1 || { echo >&2 "Command $dep not found"; exit 1; }
  done
}


_dun_check_dependencies vim fzf grep awk

# Settings defaults
NOTES_DIR=~/dun
ARCHIVE_DIR=~/dun/archive
STATUSES_TODO=('TODO')
STATUSES_BLOCK=('WAIT')
STATUSES_DONE=('WONT' 'DONE')
STATUSES_TODO_STYLE='[1;37;44m'
STATUSES_BLOCK_STYLE='[1;37;43m'
STATUSES_DONE_STYLE='[1;37;42m'
HIGHLIGHT_STYLE='[0;35m'
FILENAME_STYLE='[0;32m'
TAGS_STYLE='[1;37;46m'
VIM_STATUSES_TODO_STYLE='ctermbg=darkblue ctermfg=white cterm=bold'
VIM_STATUSES_BLOCK_STYLE='ctermbg=darkyellow ctermfg=white cterm=bold'
VIM_STATUSES_DONE_STYLE='ctermbg=darkgreen ctermfg=white cterm=bold'
VIM_TAG_STYLE='ctermbg=darkcyan ctermfg=white cterm=bold'
VIM_SUPPORT='disabled'

# Load config file
conf_file=~/.config/dun.conf
if [ -f $conf_file ]; then
  source $conf_file
fi

# Create notes dir if it doesn't exist
if [ -d "$NOTES_DIR" ]; then
  cd "$NOTES_DIR"
else
  echo -e "$NOTES_DIR does not exist (change NOTES_DIR in dun.conf for another location), type \e${HIGHLIGHT_STYLE}[c]\e[0m to create or \e${HIGHLIGHT_STYLE}anything else\e[0m to exit"
  read selection
  if [ "$selection" = "c" ]; then
    mkdir -p "$NOTES_DIR"
  else
    exit 0
  fi 
fi

case $1 in
  help)
     _dun_print_help
     ;;

  archive)
    # Move notes that have no tasks or only tasks that are done to archive directory

    # Create archive dir if it doesn't exist
    if [ ! -d "$ARCHIVE_DIR" ]; then
      echo -e "$ARCHIVE_DIR does not exist (change ARCHIVE_DIR in dun.conf for another location), type \e${HIGHLIGHT_STYLE}[c]\e[0m to create or \e${HIGHLIGHT_STYLE}anything else\e[0m to exit"
      read selection
      if [ "$selection" = "c" ]; then
        mkdir -p "$ARCHIVE_DIR"
      else
        exit 0
      fi 
    fi

    # Tasks statuses that still have work pending
    live_statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}")
    regexp=''

    for s in ${live_statuses[@]}; do
      regexp="$regexp\|$s"
    done
    regexp="${regexp:2}"

    # Loop over every archive candidate and allow user to choose how to handle it
    while read f; do

      file_name="${f##*/}"

      while true; do
        echo -e "\n\e${FILENAME_STYLE}${file_name}\e[0m\nType \e${HIGHLIGHT_STYLE}[a]\e[0m to archive, \e${HIGHLIGHT_STYLE}[v]\e[0m to view, \e${HIGHLIGHT_STYLE}[i]\e[0m to ingnore or \e${HIGHLIGHT_STYLE}anything else\e[0m to exit"
        read selection < /dev/tty

        if [ "$selection" = "a" ]; then
          mv "$f" "$ARCHIVE_DIR/." 
          echo -e "Archived \e${FILENAME_STYLE}$file_name\e[0m"
          parent_loop_control="continue"
          break
        elif [ "$selection" = "v" ]; then
          # Need to redirect new stderr so vim does not hijack parents
          vi --not-a-term "$f" < /dev/stderr
          parent_loop_control="continue"
        elif [ "$selection" = "i" ]; then
          echo -e "Ignored \e${FILENAME_STYLE}$file_name\e[0m"
          parent_loop_control="continue"
          break
        else
          parent_loop_control="break"
          break
        fi
      done

      [ "$parent_loop_control" = "break" ] && break

    done < <(grep "$regexp" --files-without-match --directories=skip $NOTES_DIR/*)

    ;;

  find)
    # Search notes dir using fzf and open selection in editor
    f="$(find "$NOTES_DIR" -not -path '*/.*' -type f | fzf --cycle "--header=Find notes")"

    # Exit cleanly if no selection was made in fzf
    [ $? -eq 130 ] && exit 0

    [ -e "$f" ] && _dun_open_editor "$f"
    ;;

  new)
    # Create new file in NOTES_DIR
    num=0

    if [ $# -eq 2 ]; then
      note_name=-$2
    else
      note_name=''
    fi

    new_file="$NOTES_DIR/$(date +%Y%m%d)$note_name"

    while [ -e "${new_file}-$num" ]; do
      num=$((num +1))
    done

    new_file="${new_file}-$num"

    _dun_open_editor "$new_file"

    ;;

  recent)
    #Select to open one of X recently modified files from NOTES_DIR or open the last modified note

    if [ "$2" != "" ]; then
      max_count=$2
    else
      max_count=10
    fi

    # find just files in NOTES_DIR and get their epoch and date stamp, sort (because epoch is first)
    # returning $max_count most recent. Use awk and sed to mangle lines so they confirm to expected input
    _dun_edit_lines "Recently modified" "LC_ALL=en_US.UTF-8 find '$NOTES_DIR' -maxdepth 1 -not -path '*/.*' -type f -exec date -r {} +%s:%Y-%m-%d\ %a\ week\ %V:{} \; | sort --reverse | head -$max_count | awk 'BEGIN { FS = \":\" } ; { print \$3 \":0:\" \$2 }' | sed 's#^$NOTES_DIR/##'"

    ;;

  open-last)
    # Open the most recently modified note

    last_modified="$(find . -maxdepth 1 -not -path '*/.*' -type f -printf '%T@ %p\n' | sort -k1,1nr | head -1 | sed 's_.*\./__')"
    [ -f "$last_modified" ] && _dun_open_editor "$last_modified" 0

    ;;

  list)
    # List tasks filtered by +<word> -<word>

    awk_filter=''
    filters=''

    if [ $# -eq 1 ]; then
      # If no filters provided, default to first todo status
      for s in ${STATUSES_TODO[0]}; do
        awk_filter="$awk_filter && /$s/"
        filters="$filters +${s}"
      done
    else
      shift

      ## Create awk command to filter lines and set arguments
      while (( $# )); do
        filters="$filters $1"
        case ${1:0:1} in
          +)
            awk_filter="$awk_filter && /${1:1}/"
            ;;
          -)
            awk_filter="$awk_filter && !/${1:1}/"
            ;;
          *)
            echo "Filters must start with either + or -"
            exit 1
            ;;
        esac
        shift
      done
    fi

    awk_filter="${awk_filter:4}" # Remove first '&& '
    # Create list of the note files, use instead of * to ensure only files and that quoteing is correct
    # The -not -path ignores dot/hidden files
    note_files="$(find . -maxdepth 1 -not -path '*/.*' -type f | sed "s/^\.\//'/ ; s/$/'/" | tr '\n' ' ')"

    _dun_edit_lines "Task filters$filters" "awk '$awk_filter {print FILENAME \":\" FNR \":\" \$0}' $note_files | sort"
    ;;

  bash-complete-options)
    # Print bash complete options

    options="archive find list new open-last recent tags bash-complete-options help"

    # tags and statuses start either with a - or +|
    statuses=("${STATUSES_TODO[@]}" "${STATUSES_BLOCK[@]}" "${STATUSES_DONE[@]}")
    readarray tags < <(_dun_list_tags)
    filters=("${statuses[@]}" "${tags[@]}")
    for ((i=0;i<${#filters[@]};i++)); do
      options="$options +${filters[$i]} -${filters[$i]}"
    done

    echo "$options" | tr -d '\n'
    ;;

  tags)
    _dun_list_tags | column -c $(tput cols) | column -t
    ;;

  *)
    echo -e 'Unknown arguments:( Maybe try \e[1mdun help\e[0m?'
    exit 1
    ;;
esac

